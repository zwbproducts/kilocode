<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku++</title>
  <style>
    :root{
      /* Surfaces */
      --bg:        #0b0e1a;        /* app background */
      --panel:     #12172a;        /* cards/toolbars */
      --panel-strong: #1a2140;
      --grid:      #2a335a;
      --cell:      #0f1430;

      /* Text */
      --text-hi:   #edf1ff;        /* main text on dark */
      --text-lo:   #a9b3d9;        /* muted text */
      --given:     #c9d4ff;        /* given numbers */
      --user:      #eef1ff;        /* user numbers */
      --muted:     #8899cc;        /* notes text */

      /* Accents */
      --accent:    #2aa5ff;        /* primary */
      --accent-2:  #1f86d6;        /* primary darker */

      /* States */
      --conflict-bg: #5a1d2a;      /* desat red, dark */
      --conflict-fg: #ffdee3;      /* light fg on conflict */
      --good:      #7ad7a3;
      --warn:      #f5c36a;
      --danger:    #ff8b7a;
    }

    @media (prefers-reduced-motion: reduce){
      *{animation: none !important; transition: none !important}
    }

    html, body{height:100%}
    body{
      margin:0; background: var(--bg);
      color: var(--text-hi); font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
      display:flex; align-items:center; justify-content:center; padding: 16px;
    }

    .app{
      width: min(100%, 1100px);
      display: grid;
      gap: 12px;
      grid-template-rows: auto 1fr;
      height: calc(100vh - 32px);
    }

    .main-content {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 16px;
        min-height: 0;
    }

    .topbar{ display:flex; align-items:center; gap:8px; background: var(--panel); padding:12px; border-radius:16px; backdrop-filter: blur(8px); border:1px solid var(--panel-strong)}
    .grow{flex:1}
    .title{font-weight:700; letter-spacing:.5px}

    .btn{ appearance:none; background: #1b2447; border: 1px solid #2a335a; color:#fff; padding:8px 12px; border-radius:12px; cursor:pointer; box-shadow: 0 1px 0 rgba(255,255,255,.05) inset; }
    .btn:hover{ filter:brightness(1.1) }
    .btn:active{ transform: translateY(1px) }
    .btn.primary{ border-color: transparent; background: linear-gradient(180deg, var(--accent), var(--accent-2)); color: #fff; }
    .btn.toggle[aria-pressed="true"]{ outline:2px solid var(--accent); }

    .select{ appearance:none; border:1px solid var(--panel-strong); background: var(--panel); color:#fff; padding:8px 10px; border-radius:12px; }

    .board-wrap{
      display: grid;
      gap: 12px;
      grid-template-rows: 1fr auto auto;
      min-height: 0;
    }

    .board{
      --size: 9; display:grid; grid-template-columns: repeat(var(--size), 1fr); border:2px solid var(--grid); border-radius:16px; overflow:hidden; background:var(--grid); position:relative;
      place-self: center;
      max-width: 100%;
      max-height: 100%;
    }
    .cell{ background:var(--cell); min-height:40px; aspect-ratio:1; display:grid; place-items:center; font-weight:600; font-size: clamp(16px, 2.2vmin, 24px); color:var(--user); position:relative; outline:none; border:1px solid rgba(255,255,255,0.05); user-select: none; }
    .cell.given{ color:var(--given); background: #10163a; font-weight: 700; }
    .cell.selected{ box-shadow: inset 0 0 0 3px var(--accent) }
    .cell.same-number{ background: linear-gradient(180deg, rgba(42,165,255,0.12), rgba(42,165,255,0.03)), var(--cell); }
    .cell.row-col, .cell.box{ background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01)), var(--cell); }

    .cell.conflict{ background: var(--conflict-bg); color: var(--conflict-fg); }
    .cell.locked{ pointer-events:none; opacity:.8 }
    .board.solved .cell{ pointer-events:none }

    .cell .notes{ position:absolute; inset:4px; display:grid; grid-auto-rows: 1fr; gap:2px; font-size: clamp(8px, 1.2vmin, 12px); opacity:.9; color: var(--muted) }
    .cell .notes span{ display:flex; align-items:center; justify-content:center; }
    .board[data-size="4"] .cell .notes { grid-template-columns: repeat(2, 1fr); }
    .board[data-size="6"] .cell .notes { grid-template-columns: repeat(3, 1fr); }
    .board[data-size="9"] .cell .notes { grid-template-columns: repeat(3, 1fr); }
    .board[data-size="12"] .cell .notes { grid-template-columns: repeat(4, 1fr); }


    /* 4x4 borders */
    .board[data-size="4"] .cell { border-width: 1px; }
    .board[data-size="4"] .cell:nth-child(2n) { border-right-width: 2px; }
    .board[data-size="4"] .cell:nth-child(4n) { border-right-width: 2px; }
    .board[data-size="4"] .cell:nth-child(n+13) { border-bottom-width: 2px; }
    .board[data-size="4"] .cell:nth-child(-n+4) { border-top-width: 2px; }
    .board[data-size="4"] .cell:nth-child(4n+1) { border-left-width: 2px; }
    .board[data-size="4"] .cell:nth-child(n+5):nth-child(-n+8) { border-bottom-width: 2px; }

    /* 6x6 borders */
    .board[data-size="6"] .cell { border-width: 1px; }
    .board[data-size="6"] .cell:nth-child(3n) { border-right-width: 2px; }
    .board[data-size="6"] .cell:nth-child(6n) { border-right-width: 2px; }
    .board[data-size="6"] .cell:nth-child(n+31) { border-bottom-width: 2px; }
    .board[data-size="6"] .cell:nth-child(-n+6) { border-top-width: 2px; }
    .board[data-size="6"] .cell:nth-child(6n+1) { border-left-width: 2px; }
    .board[data-size="6"] .cell:nth-child(n+13):nth-child(-n+18) { border-bottom-width: 2px; }

    /* 9x9 borders */
    .board[data-size="9"] .cell{ border-width:1px }
    .board[data-size="9"] .cell:nth-child(3n+1){ border-left-width:2px }
    .board[data-size="9"] .cell:nth-child(-n+9){ border-top-width:2px }
    .board[data-size="9"] .cell:nth-child(9n){ border-right-width:2px }
    .board[data-size="9"] .cell:nth-child(n+73){ border-bottom-width:2px }
    .board[data-size="9"] .cell:nth-child(3n){ border-right-width:2px }
    .board[data-size="9"] .cell:nth-child(n+19):nth-child(-n+27),
    .board[data-size="9"] .cell:nth-child(n+46):nth-child(-n+54){ border-bottom-width:2px }

    /* 12x12 borders */
    .board[data-size="12"] .cell { border-width: 1px; }
    .board[data-size="12"] .cell:nth-child(4n) { border-right-width: 2px; }
    .board[data-size="12"] .cell:nth-child(12n) { border-right-width: 2px; }
    .board[data-size="12"] .cell:nth-child(n+133) { border-bottom-width: 2px; }
    .board[data-size="12"] .cell:nth-child(-n+12) { border-top-width: 2px; }
    .board[data-size="12"] .cell:nth-child(12n+1) { border-left-width: 2px; }
    .board[data-size="12"] .cell:nth-child(n+25):nth-child(-n+36),
    .board[data-size="12"] .cell:nth-child(n+61):nth-child(-n+72),
    .board[data-size="12"] .cell:nth-child(n+97):nth-child(-n+108) { border-bottom-width: 2px; }

    .sidebar { width: 260px; }

    .num-pad {
        display: flex;
        flex-direction: column;
        gap: 12px;
        background: var(--panel);
        padding: 12px;
        border-radius: 14px;
        border: 1px solid var(--panel-strong);
    }
    .num-pad .keypad-grid { display: grid; gap: 8px; }
    .num-pad .keypad-actions { display: grid; grid-template-columns: 1fr; gap: 8px; }
    .num-pad button { font-size: 1.1em; font-weight: 600; min-height: 48px; }

    .info{ background: var(--panel); border:1px solid var(--panel-strong); border-radius:14px; padding:10px; min-height: 40px; color:#e7ebff }
    .footer{ color: var(--text-lo); font-size: 13px; text-align:center }

    /* Focus styles */
    .cell:focus-visible{ outline:2px solid var(--accent); outline-offset:-2px; z-index:3 }

    /* Modal */
    .modal{ position: fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.45) }
    .modal.open{ display:flex }
    .dialog{ background: #0e1330; color:#fff; border:1px solid var(--panel-strong); border-radius:16px; padding:18px; width:min(92vw, 480px); box-shadow: 0 20px 60px rgba(0,0,0,.5)}
    .dialog h2{ margin:0 0 8px 0 }
    .dialog .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px }

    .toolbar-right{ display:flex; gap:8px; align-items:center }
    .badge{ font-size:12px; color: var(--text-lo) }
    .sr-only{ position:absolute!important; width:1px!important; height:1px!important; padding:0!important; margin:-1px!important; overflow:hidden!important; clip:rect(0,0,0,0)!important; white-space:nowrap!important; border:0!important; }

    @media (max-width: 850px) {
        .main-content { grid-template-columns: 1fr; }
        .sidebar { width: 100%; }
        .num-pad {
            position: sticky;
            bottom: 1rem;
            z-index: 10;
        }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar" role="toolbar" aria-label="Sudoku toolbar">
      <div class="title">Sudoku++</div>
      <div class="badge" id="coordBadge">—</div>
      <div class="grow"></div>
      <button id="notesBtn" class="btn toggle" aria-pressed="false" title="Toggle notes (Shift)">Notes</button>
      <button id="newBtn" class="btn" title="N">New</button>
      <button id="hintBtn" class="btn" title="H">Hint</button>
      <button id="checkBtn" class="btn" title="C">Check</button>
      <div class="toolbar-right">
        <label class="sr-only" for="sizeSel">Size</label>
        <select id="sizeSel" class="select" aria-label="Board size">
          <option value="4">4×4</option>
          <option value="6">6×6</option>
          <option value="9" selected>9×9</option>
          <option value="12">12×12</option>
        </select>
        <label class="sr-only" for="diffSel">Difficulty</label>
        <select id="diffSel" class="select" aria-label="Difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
          <option value="expert">Expert</option>
        </select>
        <div id="timer" aria-live="polite" class="badge" title="Elapsed time">00:00</div>
      </div>
    </div>

    <div class="main-content">
        <div class="board-wrap">
          <div id="board" class="board" data-size="9" aria-label="Sudoku board" role="grid"></div>
          <div id="info" class="info" aria-live="polite" aria-atomic="true">Loading…</div>
          <div class="footer"></div>
        </div>
        <div class="sidebar">
            <div class="num-pad" id="numPad" aria-label="Number pad"></div>
        </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modal" class="modal" aria-hidden="true">
    <div id="dialog" class="dialog" role="dialog" aria-modal="true" aria-labelledby="dialogTitle" aria-describedby="dialogDesc" tabindex="-1">
      <h2 id="dialogTitle">Congratulations!</h2>
      <p id="dialogDesc">You solved the puzzle.</p>
      <div class="actions">
        <button id="closeModal" class="btn">Close</button>
        <button id="newFromModal" class="btn primary">New Game</button>
      </div>
    </div>
  </div>

  <script>
    // --- Utilities & Symbols
    const SYMBOLS = size => Array.from({length: size}, (_, i) => {
      if (size <= 9) return String(i+1);
      return i < 9 ? String(i+1) : String.fromCharCode(65 + (i - 9));
    });
    const displayOf = (n, size) => n === 0 ? '' : SYMBOLS(size)[n-1];

    // --- Game State
    const gameState = {
      size: 9,
      get boxSizeR() {
        if (this.size === 4) return 2;
        if (this.size === 6) return 2;
        if (this.size === 9) return 3;
        if (this.size === 12) return 3;
        return 3;
      },
      get boxSizeC() {
        if (this.size === 4) return 2;
        if (this.size === 6) return 3;
        if (this.size === 9) return 3;
        if (this.size === 12) return 4;
        return 3;
      },
      board: [],
      given: [],
      selected: null, // [r,c]
      notesMode: false,
      notes: new Map(), // key: r-c => Set(numbers)
      solved: false,
      undo: [],
      redo: [],
      startTime: null,
      timerId: null,
    };

    const boardEl = document.getElementById('board');
    const infoEl = document.getElementById('info');
    const numPadEl = document.getElementById('numPad');
    const sizeSel = document.getElementById('sizeSel');
    const diffSel = document.getElementById('diffSel');
    const timerEl = document.getElementById('timer');
    const notesBtn = document.getElementById('notesBtn');
    const coordBadge = document.getElementById('coordBadge');

    // ---- Sudoku Logic
    function cloneBoard(b){ return b.map(row => row.slice()); }
    function findEmpty(b){ for(let r=0;r<gameState.size;r++){ for(let c=0;c<gameState.size;c++){ if(b[r][c]===0) return [r,c]; } } return null; }

    function isValid(b, r, c, n){
      const { size, boxSizeR, boxSizeC } = gameState;
      for(let i=0;i<size;i++){
        if(i!==c && b[r][i]===n) return false;
        if(i!==r && b[i][c]===n) return false;
      }
      const br0 = Math.floor(r/boxSizeR)*boxSizeR, bc0 = Math.floor(c/boxSizeC)*boxSizeC;
      for(let i=0;i<boxSizeR;i++){
        for(let j=0;j<boxSizeC;j++){
          const rr=br0+i, cc=bc0+j;
          if((rr!==r || cc!==c) && b[rr][cc]===n) return false;
        }
      }
      return true;
    }

    function solve(b){
      const pos = findEmpty(b);
      if(!pos) return true;
      const [r,c] = pos;
      for(let n=1;n<=gameState.size;n++){
        if(isValid(b,r,c,n)){
          b[r][c]=n;
          if(solve(b)) return true;
          b[r][c]=0;
        }
      }
      return false;
    }

    function countSolutions(b, limit=2){
      const pos = findEmpty(b);
      if(!pos) return 1;
      const [r,c] = pos;
      let count=0;
      for(let n=1;n<=gameState.size && count<limit;n++){
        if(isValid(b,r,c,n)){
          b[r][c]=n;
          count += countSolutions(b, limit - count);
          b[r][c]=0;
        }
      }
      return count;
    }

    function generateSolved(){
      const { size } = gameState;
      const b = Array.from({length:size}, ()=>Array(size).fill(0));
      const nums = [...Array(size).keys()].map(i=>i+1);
      function shuffled(arr){ return arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(([_,v])=>v); }
      function helper(){
        const pos = findEmpty(b); if(!pos) return true; const [r,c]=pos;
        for(const n of shuffled(nums)){
          if(isValid(b,r,c,n)){ b[r][c]=n; if(helper()) return true; b[r][c]=0; }
        }
        return false;
      }
      helper();
      return b;
    }

    function makePuzzle(solved){
      const size=gameState.size;
      const b = cloneBoard(solved);
      const cells = [...Array(size*size).keys()];
      const start = performance.now();
      const TIME_BUDGET = 300; // ms

      function idxToRC(idx){ return [Math.floor(idx/size), idx%size]; }
      function mirror(idx){ const r=Math.floor(idx/size), c=idx%size; return r*size + (size-1-c); }

      let removals = difficultyRemovals(size, diffSel.value);
      let tries = 0, maxTries = size > 9 ? 4000 : 2000;

      while(removals>0 && tries<maxTries && cells.length){
        if(performance.now() - start > TIME_BUDGET) break;
        tries++;
        const i = Math.floor(Math.random()*cells.length);
        const idx = cells.splice(i,1)[0];
        const idx2 = mirror(idx);
        const mPos = cells.indexOf(idx2);
        if(mPos !== -1) cells.splice(mPos,1);

        const [r1,c1]=idxToRC(idx); const [r2,c2]=idxToRC(idx2);
        const backup1=b[r1][c1], backup2=b[r2][c2];
        if(backup1===0 && backup2===0) continue;
        b[r1][c1]=0; b[r2][c2]=0;
        if(countSolutions(cloneBoard(b),2)===1){ removals -= (idx===idx2?1:2); }
        else{ b[r1][c1]=backup1; b[r2][c2]=backup2; }
      }
      return b;
    }

    function difficultyRemovals(size, diff){
      const base4 = { easy: 6, medium: 8, hard: 10, expert: 11 };
      const base6 = { easy: 16, medium: 20, hard: 22, expert: 24 };
      const base9 = { easy: 40, medium: 50, hard: 56, expert: 60 };
      const base12 = { easy: 70, medium: 85, hard: 95, expert: 105 };

      if (size === 4) return base4[diff] || 8;
      if (size === 6) return base6[diff] || 20;
      if (size === 12) return base12[diff] || 85;
      return base9[diff] || 50;
    }

    // --- Rendering
    function keyFor(r,c){ return r+"-"+c; }

    function renderNumPad(){
      numPadEl.innerHTML = '';

      const gridEl = document.createElement('div');
      gridEl.className = 'keypad-grid';
      numPadEl.appendChild(gridEl);

      const actionsEl = document.createElement('div');
      actionsEl.className = 'keypad-actions';
      numPadEl.appendChild(actionsEl);

      const { size } = gameState;
      const symbols = SYMBOLS(size);

      let cols = 3;
      if (size === 4) cols = 2;
      if (size === 6) cols = 3;
      if (size === 9) cols = 3;
      if (size === 12) cols = 4;
      gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

      for(let i=1; i<=size; i++){
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = symbols[i-1];
        btn.dataset.num = String(i);
        btn.addEventListener('click', (e)=> placeNumber(i, e));
        gridEl.appendChild(btn);
      }

      const clr = document.createElement('button');
      clr.className = 'btn';
      clr.textContent = 'Clear';
      clr.addEventListener('click', clearCell);
      actionsEl.appendChild(clr);
    }

    function updateFooterText() {
        const footer = document.querySelector('.footer');
        const size = gameState.size;
        let placeKeys = '1–' + size;
        if (size > 9) {
            placeKeys = '1–9, A–' + SYMBOLS(size)[size-1];
        }
        footer.textContent = `Keyboard: arrows to move, ${placeKeys} to place, Backspace to clear. N = New, H = Hint, C = Check, Z / Shift+Z = Undo/Redo. Hold Shift or toggle Notes to pencil marks.`;
    }

    function renderBoard(){
      const size=gameState.size; const symbols=SYMBOLS(size);
      boardEl.style.setProperty('--size', size);
      boardEl.dataset.size=String(size);
      boardEl.innerHTML='';
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          const val=gameState.board[r][c];
          const cell=document.createElement('div');
          cell.className='cell';
          cell.setAttribute('role','gridcell');
          cell.tabIndex = gameState.given[r][c] ? -1 : 0;
          if(gameState.given[r][c]) cell.classList.add('given');
          cell.dataset.r=String(r); cell.dataset.c=String(c);
          cell.textContent = val? symbols[val-1] : '';
          const k=keyFor(r,c);
          if(!val && gameState.notes.get(k)?.size){
            const notesWrap=document.createElement('div'); notesWrap.className='notes';
            const set = gameState.notes.get(k);
            for(let i=1;i<= size; i++){
              const sp=document.createElement('span'); sp.textContent = set.has(i)? symbols[i-1] : '';
              notesWrap.appendChild(sp);
            }
            cell.appendChild(notesWrap);
          }
          boardEl.appendChild(cell);
        }
      }
      updateHighlights();
      updateCoordBadge();
    }

    function updateCellText(r,c){
      const cell = boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      if(!cell) return;
      cell.innerHTML='';
      const v=gameState.board[r][c];
      cell.textContent = displayOf(v, gameState.size);
      if(!v){
        const k=keyFor(r,c), set=gameState.notes.get(k);
        if(set?.size){
          const wrap=document.createElement('div'); wrap.className='notes';
          const symbols=SYMBOLS(gameState.size);
          for(let i=1;i<= gameState.size; i++){
            const sp=document.createElement('span'); sp.textContent = set.has(i)? symbols[i-1] : '';
            wrap.appendChild(sp);
          }
          cell.appendChild(wrap);
        }
      }
    }

    function setSelected(r,c){
      gameState.selected=[r,c];
      for(const el of boardEl.querySelectorAll('.cell.selected')) el.classList.remove('selected');
      const cell = boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      if(cell){ cell.classList.add('selected'); cell.setAttribute('aria-selected','true'); cell.focus(); }
      updateHighlights();
      updateCoordBadge();
    }

    function updateCoordBadge(){
      if(!gameState.selected){ coordBadge.textContent='—'; return; }
      const [r,c]=gameState.selected; const v=gameState.board[r][c];
      coordBadge.textContent = `r${r+1} c${c+1} ${v? '· '+displayOf(v,gameState.size):''}`;
    }

    function updateHighlights(){
      const size=gameState.size;
      const sel=gameState.selected;
      for (const el of boardEl.querySelectorAll('.cell')) {
        el.classList.remove('row-col','box','same-number');
        el.removeAttribute('aria-selected');
      }
      if(!sel) return;

      const [r,c]=sel;
      const { boxSizeR, boxSizeC } = gameState;
      const selectedEl = boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      selectedEl?.setAttribute('aria-selected','true');

      for(const el of boardEl.querySelectorAll(`.cell[data-r="${r}"]`)) el.classList.add('row-col');
      for(const el of boardEl.querySelectorAll(`.cell[data-c="${c}"]`)) el.classList.add('row-col');
      const br0=Math.floor(r/boxSizeR)*boxSizeR, bc0=Math.floor(c/boxSizeC)*boxSizeC;
      for(let i=0;i<boxSizeR;i++) for(let j=0;j<boxSizeC;j++){
        boardEl.querySelector(`.cell[data-r="${br0+i}"][data-c="${bc0+j}"]`)?.classList.add('box');
      }

      const same = gameState.board[r][c];
      if(same){
        for(let rr=0; rr<size; rr++){
          for(let cc=0; cc<size; cc++){
            if(gameState.board[rr][cc]===same){
              boardEl.querySelector(`.cell[data-r="${rr}"][data-c="${cc}"]`)?.classList.add('same-number');
            }
          }
        }
      }
    }

    function clearCell(){ if(!gameState.selected) return; const [r,c]=gameState.selected; if(gameState.given[r][c]) return; applyMove({type:'set', r,c, prev:gameState.board[r][c], next:0}); setNumber(r,c,0); updateCellText(r,c); postPlace(r,c); }

    function placeNumber(n, e){
      if(!gameState.selected) return;
      const [r,c]=gameState.selected;
      if(gameState.given[r][c]) return;
      const usingNotes = gameState.notesMode || (e?.shiftKey === true);
      if(usingNotes){ toggleNote(r,c,n,true); return; }
      applyMove({type:'set', r,c, prev:gameState.board[r][c], next:n});
      setNumber(r,c,n); updateCellText(r,c); postPlace(r,c);
    }

    function toggleNote(r,c,n,explicit=false){ if(gameState.board[r][c]) return; const k=keyFor(r,c); if(!gameState.notes.has(k)) gameState.notes.set(k,new Set()); const set=gameState.notes.get(k); if(set.has(n)) set.delete(n); else set.add(n); updateCellText(r,c); if(explicit && typeof navigator.vibrate === 'function') navigator.vibrate(15); }

    function setNumber(r,c,n){
      const b=gameState.board;
      b[r][c]=n;
      gameState.notes.delete(keyFor(r,c));
      if(n){
        const { size, boxSizeR, boxSizeC } = gameState;
        for(let i=0;i<size;i++){
          gameState.notes.get(keyFor(r,i))?.delete(n); updateCellText(r,i);
          gameState.notes.get(keyFor(i,c))?.delete(n); updateCellText(i,c);
        }
        const br0=Math.floor(r/boxSizeR)*boxSizeR, bc0=Math.floor(c/boxSizeC)*boxSizeC;
        for(let i=0;i<boxSizeR;i++) for(let j=0;j<boxSizeC;j++){ const rr=br0+i, cc=bc0+j; gameState.notes.get(keyFor(rr,cc))?.delete(n); updateCellText(rr,cc); }
      }
    }

    function postPlace(r,c){
      const n=gameState.board[r][c];
      const size=gameState.size; let conflict=false; if(n){
        for(let i=0;i<size;i++){
          if(i!==c && gameState.board[r][i]===n) conflict=true;
          if(i!==r && gameState.board[i][c]===n) conflict=true;
        }
        const { boxSizeR, boxSizeC } = gameState;
        const br0=Math.floor(r/boxSizeR)*boxSizeR, bc0=Math.floor(c/boxSizeC)*boxSizeC;
        for(let i=0;i<boxSizeR;i++) for(let j=0;j<boxSizeC;j++){ const rr=br0+i, cc=bc0+j; if((rr!==r||cc!==c) && gameState.board[rr][cc]===n) conflict=true; }
      }
      const cell = boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); if(cell){ cell.classList.toggle('conflict', conflict); }
      updateHighlights();
      checkSolved();
    }

    function checkSolved(){
      for(let r=0;r<gameState.size;r++) for(let c=0;c<gameState.size;c++){ if(gameState.board[r][c]===0) return false; }
      const b=cloneBoard(gameState.board);
      for(let r=0;r<gameState.size;r++) for(let c=0;c<gameState.size;c++){ const n=b[r][c]; if(!isValid(b,r,c,n)) return false; }
      win(); return true;
    }

    // --- Undo/Redo
    function applyMove(m){ gameState.undo.push(m); gameState.redo.length=0; }
    function undo(){ const m=gameState.undo.pop(); if(!m) return; gameState.redo.push(m); if(m.type==='set'){ gameState.board[m.r][m.c]=m.prev; updateCellText(m.r,m.c); postPlace(m.r,m.c); } }
    function redo(){ const m=gameState.redo.pop(); if(!m) return; gameState.undo.push(m); if(m.type==='set'){ gameState.board[m.r][m.c]=m.next; updateCellText(m.r,m.c); postPlace(m.r,m.c); } }

    // --- Timer
    function startTimer(){ stopTimer(); gameState.startTime=Date.now(); timerEl.textContent='00:00'; gameState.timerId=setInterval(()=>{ const d=Date.now()-gameState.startTime; const m=Math.floor(d/60000), s=Math.floor((d%60000)/1000); timerEl.textContent=String(m).padStart(2,'0')+":"+String(s).padStart(2,'0'); }, 1000); }
    function stopTimer(){ if(gameState.timerId){ clearInterval(gameState.timerId); gameState.timerId=null; } }

    // --- Modal + focus trap
    const modal = document.getElementById('modal');
    const dialog = document.getElementById('dialog');
    const closeModalBtn = document.getElementById('closeModal');
    const newFromModalBtn = document.getElementById('newFromModal');
    let lastFocused = null;

    function openModal(){ lastFocused=document.activeElement; modal.classList.add('open'); modal.removeAttribute('aria-hidden'); dialog.focus(); document.addEventListener('keydown', trapTab); document.addEventListener('keydown', escClose); stopTimer(); }
    function closeModal(){ modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); document.removeEventListener('keydown', trapTab); document.removeEventListener('keydown', escClose); lastFocused?.focus(); }
    function trapTab(e){ if(e.key!=='Tab') return; const focusable=dialog.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); if(!focusable.length) return; const first=focusable[0], last=focusable[focusable.length-1]; if(e.shiftKey && document.activeElement===first){ last.focus(); e.preventDefault(); } else if(!e.shiftKey && document.activeElement===last){ first.focus(); e.preventDefault(); } }
    function escClose(e){ if(e.key==='Escape') closeModal(); }
    closeModalBtn.addEventListener('click', closeModal); newFromModalBtn.addEventListener('click', ()=>{ closeModal(); newGame(); });

    function win(){ gameState.solved=true; boardEl.classList.add('solved'); infoEl.textContent='Solved! Great job.'; openModal(); }

    // --- Events (board)
    boardEl.addEventListener('click', (e)=>{
      const cell=e.target.closest('.cell'); if(!cell) return; const r=+cell.dataset.r, c=+cell.dataset.c; setSelected(r,c);
    });

    boardEl.addEventListener('keydown', (e)=>{
      if(!gameState.selected) return; const [r,c]=gameState.selected; const size=gameState.size; const key=e.key.toUpperCase();
      const symbols=SYMBOLS(size); const idx=symbols.indexOf(key);
      if(idx!==-1){ placeNumber(idx+1, e); e.preventDefault(); return; }
      if(key==='BACKSPACE' || key==='DELETE'){ clearCell(); e.preventDefault(); return; }
      if(key==='ARROWRIGHT'){ setSelected(r, Math.min(size-1, c+1)); e.preventDefault(); return; }
      if(key==='ARROWLEFT'){ setSelected(r, Math.max(0, c-1)); e.preventDefault(); return; }
      if(key==='ARROWDOWN'){ setSelected(Math.min(size-1, r+1), c); e.preventDefault(); return; }
      if(key==='ARROWUP'){ setSelected(Math.max(0, r-1), c); e.preventDefault(); return; }
      if(key==='N'){ newGame(); return; }
      if(key==='H'){ hint(); return; }
      if(key==='C'){ checkBoard(); return; }
      if(key==='Z' && (e.ctrlKey||e.metaKey)){ if(e.shiftKey) redo(); else undo(); e.preventDefault(); return; }
    });

    // --- Toolbar
    document.getElementById('newBtn').addEventListener('click', newGame);
    document.getElementById('hintBtn').addEventListener('click', hint);
    document.getElementById('checkBtn').addEventListener('click', checkBoard);
    notesBtn.addEventListener('click', ()=>{ gameState.notesMode=!gameState.notesMode; notesBtn.setAttribute('aria-pressed', String(gameState.notesMode)); info(`Notes ${gameState.notesMode? 'on':'off'}.`); });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Shift') notesBtn.setAttribute('aria-pressed','true'); });
    window.addEventListener('keyup', (e)=>{ if(e.key==='Shift') notesBtn.setAttribute('aria-pressed', String(gameState.notesMode)); });

    sizeSel.addEventListener('change', ()=> newGame());
    diffSel.addEventListener('change', ()=> newGame());

    // --- Info
    function info(msg){ infoEl.textContent=msg; }

    // --- Hints & Checks
    function hint(){
      const b=cloneBoard(gameState.board); if(!solve(b)){ info('No solution found.'); return; }
      for(let r=0;r<gameState.size;r++){
        for(let c=0;c<gameState.size;c++){
          if(gameState.board[r][c]===0){ const n=b[r][c]; applyMove({type:'set', r,c, prev:0, next:n}); setNumber(r,c,n); updateCellText(r,c); postPlace(r,c); info('Hint placed.'); return; }
        }
      }
      info('Nothing to hint.');
    }

    function checkBoard(){
      for (const el of boardEl.querySelectorAll('.cell')) el.classList.remove('conflict');
      let mistakes=0;
      const size=gameState.size;
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          const n=gameState.board[r][c];
          if(n===0) continue;
          const ok=isValid(gameState.board, r,c,n);
          if(!ok){
            boardEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`)?.classList.add('conflict');
            mistakes++;
          }
        }
      }
      info(mistakes? `${mistakes} mistake${mistakes>1?'s':''} highlighted.` : 'Looks good so far!');
    }


    // --- New Game
    function newGame(){
      stopTimer();
      const size = parseInt(sizeSel.value,10); gameState.size=size; gameState.notes.clear(); gameState.undo.length=0; gameState.redo.length=0; gameState.solved=false; boardEl.classList.remove('solved');
      info('Generating puzzle…');
      setTimeout(() => {
        const solved = generateSolved();
        const puzzle = makePuzzle(solved);
        gameState.board = puzzle;
        gameState.given = puzzle.map(row => row.map(v => v!==0));
        renderBoard();
        let sel=null; for(let r=0;r<size;r++){ for(let c=0;c<size;c++){ if(!gameState.given[r][c]) { sel=[r,c]; break; } } if(sel) break; }
        setSelected(sel? sel[0]:0, sel? sel[1]:0);
        renderNumPad();
        updateFooterText();
        info('Good luck!');
        startTimer();
      }, 10);
    }

    // --- Layout Sizing
    function sizeBoardToViewport(){
      const wrap = document.querySelector('.board-wrap');
      const board = boardEl;
      if (!wrap || !board) return;
      const wrapStyles = getComputedStyle(wrap);
      const gap = parseFloat(wrapStyles.rowGap) || 0;
      const infoH   = document.getElementById('info').offsetHeight;
      const footerH = document.querySelector('.footer').offsetHeight;
      const available = wrap.clientHeight - (infoH + footerH + 2*gap);
      const size = Math.max(0, available);
      const maxWidth = wrap.clientWidth;
      const side = Math.min(size, maxWidth);
      board.style.width  = side + 'px';
      board.style.height = side + 'px';
    }

    window.addEventListener('resize', sizeBoardToViewport);

    // --- Function Wrappers for Layout
    const _oldRenderBoard = renderBoard;
    renderBoard = function(){
      _oldRenderBoard();
      sizeBoardToViewport();
    };

    const _oldNewGame = newGame;
    newGame = function(){
      _oldNewGame();
      setTimeout(sizeBoardToViewport, 15); // Allow DOM to update
    };

    // --- Boot
    newGame();
  </script>
</body>
</html>